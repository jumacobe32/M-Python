import pandas as pd
from pathlib import Path
import re 
import numpy as np 

# --- CONFIGURACI√ìN ---
# ¬°CAMBIA ESTA URL! Debe ser la URL de EXPORTACI√ìN CSV de tu Google Sheet.
# Ejemplo de formato de URL de exportaci√≥n:
# "https://docs.google.com/spreadsheets/d/<ID_DEL_DOCUMENTO>/gviz/tq?tqx=out:csv&sheet=<NOMBRE_DE_LA_HOJA>"
GOOGLE_SHEET_URL = "https://docs.google.com/spreadsheets/d/1EK96qUKEW2dfnRBT7NfeVouAFouUXDOvHRVVGJ8gs34/edit?pli=1&gid=1118832498#gid=1118832498"
NOMBRE_HOJA_EXCEL = "NUEVO DESEMPE√ëO" # Solo para referencia en logs
OUTPUT_FILENAME = 'ConceptosProdFlag.xlsx'

# Mapeo de columnas M a √≠ndices de Pandas (0-indexado)
# La lectura desde CSV/URL no permite forzar dtypes tan f√°cilmente como Excel.
COLUMNA_FILTRO_INDEX = 8 # Columna I
COLUMNAS_SELECCIONADAS_INDEX = [1, 5, 8] # Columnas B, F, I
COLUMNAS_FINALES_NOMBRES = ["Column2", "Column6", "Column9"] 

MAX_COLUMNA_INDEX = max(COLUMNAS_SELECCIONADAS_INDEX) + 1 

def extraer_y_transformar_desempeno() -> pd.DataFrame:
    """Implementa la l√≥gica de lectura, filtrado y selecci√≥n de columnas desde Google Sheet."""
    
    print(f"Iniciando extracci√≥n y transformaci√≥n de la hoja '{NOMBRE_HOJA_EXCEL}' desde URL...")
    
    # 1. Origen: Lectura con skiprows=10 desde URL
    try:
        # Al leer un CSV, no se puede pre-asignar nombres con 'names' si no se conoce la longitud exacta de las columnas.
        # Primero, leemos solo el bloque de datos que nos interesa (saltando 10 filas).
        df_completo = pd.read_csv(
            GOOGLE_SHEET_URL,
            header=None, 
            skiprows=10, # Fila 11 de Excel/Sheet
            dtype=str # Forzar TODAS las columnas a STR para manejar el filtro '1'
        )
        
        # Asignar nombres gen√©ricos despu√©s de la lectura
        nombres_forzados = [f'Column{i+1}' for i in range(len(df_completo.columns))]
        df_completo.columns = nombres_forzados
        df = df_completo
        
    except Exception as e:
        print(f"‚ùå Error cr√≠tico de lectura de Google Sheets: {e}")
        print("Aseg√∫rate de que la URL de exportaci√≥n CSV sea correcta y accesible.")
        return pd.DataFrame()
    
    columna_filtro_nombre = f'Column{COLUMNA_FILTRO_INDEX + 1}'
    print(f"\n‚úÖ PASO 1: Archivo le√≠do. Filtro en {columna_filtro_nombre} (Columna I).")

    # 2. Aplicamos el filtro de texto estricto (ROBUSTO)
    print(f"‚úÖ PASO 2: Aplicando filtro robusto para valores de texto '1'.")
    try:
        # --- FILTRO ROBUSTO MANTENIDO ---
        # 1. Rellenar nulos con cadena vac√≠a ('') para permitir que .str funcione sin fallos.
        # 2. Convertir a string (ya forzado, pero se mantiene la cadena de m√©todos).
        # 3. Eliminar caracteres invisibles (\r, \n, etc.).
        # 4. Limpiar espacios iniciales/finales.
        columna_texto_limpia = (
            df[columna_filtro_nombre]
            .fillna('') # Evita errores de NaN
            .astype(str)
            .str.replace(r'[\r\n\t\x00]', '', regex=True) 
            .str.strip() 
        )
        
        # Filtrar donde el valor de texto limpio sea EXACTAMENTE '1'
        df_filtrado = df[
            columna_texto_limpia == '1'
        ].copy()
        
    except Exception as e:
        print(f"‚ùå ERROR CR√çTICO al aplicar el filtro: {e}")
        return pd.DataFrame()
    
    # 3. Selecci√≥n y Renombrado
    
    columnas_a_mantener = [f'Column{i + 1}' for i in COLUMNAS_SELECCIONADAS_INDEX]
    columnas_presentes = [col for col in columnas_a_mantener if col in df_filtrado.columns]
    
    df_final = df_filtrado[columnas_presentes]
    
    if len(df_final.columns) == len(COLUMNAS_FINALES_NOMBRES):
        # Renombrar Column2, Column6, y Column9 (FLAG) a los nombres finales
        df_final.columns = COLUMNAS_FINALES_NOMBRES
    
    print("‚úîÔ∏è PASO 3: Selecci√≥n y Renombrado completado.")
    return df_final


# ----------------------------------------------------------------------------------
## EJECUCI√ìN Y EXPORTACI√ìN
# ----------------------------------------------------------------------------------

if __name__ == '__main__':
    
    df_final = extraer_y_transformar_desempeno()
    
    if df_final.empty:
        print("\nüõë El DataFrame final est√° vac√≠o. Finalizando.")
        print("La sintaxis es correcta y es robusta. El valor de texto limpio '1' NO se encontr√≥ en la Columna I despu√©s de saltar 10 filas.")
        exit()
    
    # EXPORTACI√ìN DEL RESULTADO
    try:
        descargas_dir = Path.home() / 'Downloads'
        output_path = descargas_dir / OUTPUT_FILENAME

        df_final.to_excel(output_path, index=False)
        
        print("\n================ EXPORTACI√ìN ================")
        print(f"‚úÖ Exportaci√≥n exitosa a Excel. Archivo guardado en: {output_path}")

    except Exception as e:
        print(f"‚ùå Error al exportar el archivo: {e}")
        
    # Resultado final en pantalla
    print("\n================ RESULTADO FINAL ================")
    print(f"Filas procesadas: {len(df_final)}")
    print("Primeras 5 filas (Column2, Column6, Column9):")
    print(df_final.head())