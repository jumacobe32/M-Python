import subprocess
import sys
import os
from typing import List
from datetime import datetime

# ==============================================================================
#                      CONFIGURACI√ìN PRINCIPAL
# ==============================================================================

# üõë 1. RUTA AL INT√âRPRETE DE PYTHON
# Se recomienda usar 'python' si est√° en el PATH. Si no funciona, reemplace con la ruta completa.
PYTHON_EXECUTABLE = 'python' 

# üõë 2. LISTA DE SCRIPTS A EJECUTAR
# Aseg√∫rese de que las rutas y extensiones de sus scripts (.py) sean correctas.
SCRIPTS_TO_RUN: List[str] = [
    r'C:\Users\USUARIO\Documents\Juan Manuel Cortes Benitez\Python\Import Power Bi M to Python\Ext_data.py',
    # A√±ada m√°s rutas de scripts aqu√≠:
    # r'C:\ruta\al\script_B.py',
    # r'C:\ruta\al\script_C.py',
]

# üõë 3. CONFIGURACI√ìN DEL ARCHIVO DE LOG
# Directorio donde se guardar√° el archivo de log.
LOG_BASE_DIR = r'C:\Users\USUARIO\Documents\Juan Manuel Cortes Benitez\Python\Procesamiento_Scripts'
# Prefijo del nombre del archivo de log.
LOG_FILE_PREFIX = 'Procesamiento_Scripts'


# ==============================================================================
#                      FUNCI√ìN DE LOGGING
# ==============================================================================

def log_message(message: str, log_path: str):
    """A√±ade marca de tiempo al mensaje, lo imprime en consola y lo escribe en el archivo de log."""
    
    # A√±adir marca de tiempo: [YYYY-MM-DD HH:MM:SS]
    timestamp = datetime.now().strftime("[%Y-%m-%d %H:%M:%S]")
    full_message = f"{timestamp} {message}"
    
    # 1. Imprimir en consola
    print(full_message)
    
    # 2. Escribir en archivo de log
    try:
        # Asegurarse de que el directorio del log exista
        log_dir = os.path.dirname(log_path)
        # Si log_dir no est√° vac√≠o, crea el directorio si no existe.
        if log_dir and not os.path.exists(log_dir):
            os.makedirs(log_dir, exist_ok=True)
            
        with open(log_path, 'a', encoding='utf-8') as f:
            f.write(full_message + "\n")
            
    except Exception as e:
        # Esto solo se imprime en consola si falla el log
        print(f"‚ùå ERROR DE LOGGING: No se pudo escribir en el archivo {log_path}. Raz√≥n: {e}")

# ==============================================================================
#                      FUNCI√ìN DE EJECUCI√ìN
# ==============================================================================

def execute_python_script(script_path: str, python_exe: str, log_path: str) -> bool:
    """Ejecuta un script Python usando subprocess y registra el resultado."""
    
    script_name = os.path.basename(script_path)
    
    # 1. Registrar Inicio
    log_message(f"--- INICIANDO PROCESO: {script_name} ---", log_path)
    
    comando = [python_exe, script_path]
    log_message(f"   Comando: {' '.join(comando)}", log_path)
    
    try:
        # Ejecutar el proceso y capturar la salida
        resultado = subprocess.run(
            comando, 
            capture_output=True, 
            text=True, 
            check=False, # Permite manejar el c√≥digo de retorno manualmente
            encoding='utf-8',       
            errors='replace',
            env=dict(os.environ, PYTHONIOENCODING='utf-8')    
        )
        
        return_code = resultado.returncode
        
        if return_code == 0:
            # 2. Registrar √âxito
            log_message(f"‚úîÔ∏è √âXITO: {script_name} completado (C√≥digo 0).", log_path)
            
            # Registrar la salida est√°ndar (stdout) si existe
            if resultado.stdout and resultado.stdout.strip():
                log_message(f"   Salida Est√°ndar (stdout):\n{resultado.stdout.strip()}", log_path)
            return True
        else:
            # 3. Registrar Fallo
            log_message(f"‚ùå FALLO: {script_name} finaliz√≥ con C√ìDIGO DE ERROR {return_code}.", log_path)
            log_message("--- Salida de Error Est√°ndar (stderr) ---", log_path)
            
            # Chequear por None antes de llamar a strip()
            error_output = resultado.stderr if resultado.stderr is not None else ""
            log_message(error_output.strip() or "No hay mensajes de error espec√≠ficos.", log_path)
            
            log_message("-----------------------------------------", log_path)
            
            if return_code == 2:
                log_message("‚ö†Ô∏è DIAGN√ìSTICO: C√≥digo 2 = Archivo/Comando no encontrado. Revise rutas.", log_path)
            
            return False

    except FileNotFoundError:
        log_message(f"‚ùå ERROR CR√çTICO: El int√©rprete '{python_exe}' no fue encontrado.", log_path)
        log_message("   Aseg√∫rese de que Python est√° en el PATH o que la ruta es correcta.", log_path)
        return False
    except Exception as e:
        log_message(f"‚ùå ERROR INESPERADO al ejecutar {script_name}: {e}", log_path)
        return False

# ==============================================================================
#                      EJECUCI√ìN DEL FLUJO PRINCIPAL
# ==============================================================================

if __name__ == '__main__':
    
    # 0. Generar el nombre de archivo de log din√°mico con fecha y hora
    timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
    LOG_FILE_PATH = os.path.join(LOG_BASE_DIR, f"{LOG_FILE_PREFIX}_{timestamp_str}.log")
    
    # 1. Configuraci√≥n inicial del log
    log_message(f"\n########################################################", LOG_FILE_PATH)
    log_message(f"####### INICIO DE PROCESAMIENTO MULTI-SCRIPT ###########", LOG_FILE_PATH)
    log_message(f"Log de salida en: {LOG_FILE_PATH}", LOG_FILE_PATH)
    log_message(f"Iniciando el procesamiento de {len(SCRIPTS_TO_RUN)} scripts...", LOG_FILE_PATH)
    log_message(f"Python Executable: {PYTHON_EXECUTABLE}", LOG_FILE_PATH)
    log_message(f"########################################################\n", LOG_FILE_PATH)
    
    scripts_fallidos = []
    
    # 2. Recorre y ejecuta cada script
    for script_file in SCRIPTS_TO_RUN:
        exito = execute_python_script(script_file, PYTHON_EXECUTABLE, LOG_FILE_PATH)
        
        if not exito:
            scripts_fallidos.append(script_file)
            
            # Puedes agregar aqu√≠ una l√≥gica para detener todo el proceso 
            # si un script es CR√çTICO y falla (ej: break)
            # break 
    
    # 3. Resumen Final
    log_message("\n========================================================", LOG_FILE_PATH)
    log_message("               RESUMEN DE PROCESAMIENTO                 ", LOG_FILE_PATH)
    log_message("========================================================", LOG_FILE_PATH)
    
    if not scripts_fallidos:
        log_message("üéâ Todos los scripts se ejecutaron con √©xito.", LOG_FILE_PATH)
        sys.exit(0) # Salida de √©xito global
    else:
        log_message(f"üö® Se detectaron {len(scripts_fallidos)} fallos en los siguientes scripts:", LOG_FILE_PATH)
        for script in scripts_fallidos:
            log_message(f" - {script}", LOG_FILE_PATH)
        
        log_message(f"################ FIN DE PROCESAMIENTO ##################\n", LOG_FILE_PATH)
        sys.exit(1) # Salida de fallo global